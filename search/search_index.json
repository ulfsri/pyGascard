{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyGascard","text":"<p>Python API for acquisition and control of Edinburgh Sensors Gascard</p> <p>See Edinburgh Sensors Gascard Communications Guide for reference.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install -U pyGascard\n</code></pre> <p>or install with <code>Poetry</code></p> <pre><code>poetry add pyGascard\n</code></pre>"},{"location":"#makefile-usage","title":"Makefile usage","text":"<p><code>Makefile</code> contains a lot of functions for faster development.</p> 1. Download and remove Poetry <p>  To download and install Poetry run:  <pre><code>make poetry-download\n</code></pre>  To uninstall  <pre><code>make poetry-remove\n</code></pre> </p> 2. Install all dependencies and pre-commit hooks <p>  Install requirements:  <pre><code>make install\n</code></pre>  Pre-commit hooks coulb be installed after `git init` via  <pre><code>make pre-commit-install\n</code></pre> </p> 3. Codestyle <p>  Automatic formatting uses `pyupgrade`, `isort` and `black`.  <pre><code>make codestyle\n\n# or use synonym\nmake formatting\n</code></pre>  Codestyle checks only, without rewriting files:  <pre><code>make check-codestyle\n</code></pre>  &gt; Note: `check-codestyle` uses `isort`, `black` and `darglint` library  Update all dev libraries to the latest version using one comand  <pre><code>make update-dev-deps\n</code></pre> 4. Code security <p> <pre><code>make check-safety\n</code></pre>  This command launches `Poetry` integrity checks as well as identifies security issues with `Safety` and `Bandit`.  <pre><code>make check-safety\n</code></pre> </p> </p> 5. Type checks <p>  Run `mypy` static type checker  <pre><code>make mypy\n</code></pre> </p> 6. Tests with coverage badges <p>  Run `pytest`  <pre><code>make test\n</code></pre> </p> 7. All linters <p>  Of course there is a command to ~~rule~~ run all linters in one:  <pre><code>make lint\n</code></pre>  the same as:  <pre><code>make test &amp;&amp; make check-codestyle &amp;&amp; make mypy &amp;&amp; make check-safety\n</code></pre> </p> 8. Docker <p> <pre><code>make docker-build\n</code></pre>  which is equivalent to:  <pre><code>make docker-build VERSION=latest\n</code></pre>  Remove docker image with  <pre><code>make docker-remove\n</code></pre>  More information [about docker](https://github.com/ulfsri/pyGascard/tree/main/docker).  </p> 9. Cleanup <p> Delete pycache files  <pre><code>make pycache-remove\n</code></pre>  Remove package build  <pre><code>make build-remove\n</code></pre>  Delete .DS_STORE files  <pre><code>make dsstore-remove\n</code></pre>  Remove .mypycache  <pre><code>make mypycache-remove\n</code></pre>  Or to remove all above run:  <pre><code>make cleanup\n</code></pre> </p>"},{"location":"#releases","title":"\ud83d\udcc8 Releases","text":"<p>You can see the list of available releases on the GitHub Releases page.</p> <p>We follow Semantic Versions specification.</p> <p>We use <code>Release Drafter</code>. As pull requests are merged, a draft release is kept up-to-date listing the changes, ready to publish when you\u2019re ready. With the categories option, you can categorize pull requests in release notes using labels.</p>"},{"location":"#list-of-labels-and-corresponding-titles","title":"List of labels and corresponding titles","text":"Label Title in Releases <code>enhancement</code>, <code>feature</code> \ud83d\ude80 Features <code>bug</code>, <code>refactoring</code>, <code>bugfix</code>, <code>fix</code> \ud83d\udd27 Fixes &amp; Refactoring <code>build</code>, <code>ci</code>, <code>testing</code> \ud83d\udce6 Build System &amp; CI/CD <code>breaking</code> \ud83d\udca5 Breaking Changes <code>documentation</code> \ud83d\udcdd Documentation <code>dependencies</code> \u2b06\ufe0f Dependencies updates <p>You can update it in <code>release-drafter.yml</code>.</p> <p>GitHub creates the <code>bug</code>, <code>enhancement</code>, and <code>documentation</code> labels for you. Dependabot creates the <code>dependencies</code> label. Create the remaining labels on the Issues tab of your GitHub repository, when you need them.</p>"},{"location":"#license","title":"\ud83d\udee1 License","text":"<p>This project is licensed under the terms of the <code>MIT</code> license. See LICENSE for more details.</p>"},{"location":"#citation","title":"\ud83d\udcc3 Citation","text":"<pre><code>@misc{pyGascard,\n  author = {ulfsri},\n  title = {Python API for acquisition and control of Edinburgh Sensors Gascard},\n  year = {2024},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  howpublished = {\\url{https://github.com/ulfsri/pyGascard}}\n}\n</code></pre>"},{"location":"#credits","title":"Credits","text":"<p>This project was generated with <code>python-package-template</code></p>"},{"location":"device-reference/","title":"Device module","text":"<p>Gascard device class.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If device is not in the correct mode.</p> <code>ValueError</code> <p>If device is not found on port.</p> <code>ValueError</code> <p>If mode is invalid.</p> <code>ValueError</code> <p>If gas is not accepted.</p> <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p>"},{"location":"device-reference/#pygascard.device.Gascard","title":"<code>Gascard</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Gascard class.</p> Source code in <code>pygascard/device.py</code> <pre><code>class Gascard(ABC):\n    \"\"\"Gascard class.\"\"\"\n\n    def __init__(\n        self, device: SerialDevice, dev_info: dict[str, str], **kwargs: Any\n    ) -&gt; None:\n        \"\"\"Initialize the Gascard object.\n\n        Args:\n            device (SerialDevice): The serial device object.\n            dev_info (dict): The device information dictionary.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        self._device = device\n        self._dev_info = dev_info\n        self._current_mode = \"U\"\n        self._MODES = (\n            \"N\",\n            \"N1\",\n            \"C1\",\n            \"E1\",\n            \"O1\",\n            \"D\",\n            \"X\",\n            \"U\",\n        )\n\n    @classmethod\n    async def new_device(cls, port: str, **kwargs: Any) -&gt; \"Gascard\":\n        \"\"\"Creates a new device. Chooses appropriate device based on characteristics.\n\n        Example:\n            dev = run(Gascard.new_device, \"/dev/ttyUSB4\")\n\n        Args:\n            port (str): The port of the device.\n            **kwargs: Any\n\n        Returns:\n            Device: The new device.\n        \"\"\"\n        if port.startswith(\"/dev/\"):\n            device = SerialDevice(port, **kwargs)\n        await device._write(\"U\")\n        dev_info_raw = await device._readline()\n        if not dev_info_raw:\n            raise ValueError(\"No device found on port\")\n        dev_info_raw = dev_info_raw.replace(\"\\x00\", \"\")\n        dev_info = dict(zip(U_labels, dev_info_raw.split()))\n        if \"U\" not in dev_info_raw.split()[0]:\n            # print(\"Error: Gas Card Not in User Interface Mode\")\n            raise ValueError(\"Gas Card Not in User Interface Mode\")\n        return cls(device, dev_info, **kwargs)\n\n    async def _get_mode(self) -&gt; str:\n        \"\"\"Gets the current mode of the device.\n\n        Returns:\n            str: Current mode of device\n        \"\"\"\n        ret = await self._device._readline()\n        mode = ret[:2].strip()\n        if mode in self._MODES:\n            self.current_mode = mode\n        else:\n            raise ValueError(\"Invalid Mode\")\n        return mode\n\n    async def _set_mode(self, mode: str) -&gt; None:\n        \"\"\"Sets the mode of the device.\n\n        Args:\n            mode (str): Desired mode for device\n        \"\"\"\n        if mode in self._MODES:\n            await self._device._write(mode)\n            self._current_mode = mode\n        else:\n            raise ValueError(\"Invalid Mode\")\n        return\n\n    async def _get_val(self) -&gt; dict[str, str | float]:\n        \"\"\"Gets the current value of the device.\n\n        Returns:\n            dict[str, str | float]: Normal (N) mode dataframe\n        \"\"\"\n        if self._current_mode != \"N\":\n            await self._set_mode(\"N\")\n        ret = await self._device._readline()\n        ret = ret.replace(\"\\x00\", \"\")\n        df = ret.split()\n        if \"N\" not in df[0]:\n            raise ValueError(\"Gas Card Not in Normal Mode\")\n        for index in range(len(df)):\n            try:\n                df[index] = float(df[index])\n            except ValueError:\n                pass\n        return dict(zip(N_labels, df))\n\n    async def _get_raw(self) -&gt; dict[str, str | float]:\n        \"\"\"Gets the raw sensor output.\n\n        Returns:\n            dict[str, str | float]: Normal Channel (N1) mode Dataframe\n        \"\"\"\n        if self._current_mode != \"N1\":\n            await self._set_mode(\"N1\")\n        ret = await self._device._readline()\n        ret = ret.replace(\"\\x00\", \"\")\n        df = ret.split()\n        if \"N1\" not in df[:2]:\n            raise ValueError(\"Gas Card Not in Normal Mode\")\n        for index in range(len(df)):\n            try:\n                df[index] = float(df[index])\n            except ValueError:\n                pass\n        return dict(zip(N1_labels, df))\n\n    async def _get_coeff(self) -&gt; dict[str, str | float]:\n        \"\"\"Gets the current value of the device.\n\n        Returns:\n            dict[str, str | float]: Coefficient Channel (C1) mode dataframe\n        \"\"\"\n        if self._current_mode != \"C1\":\n            await self._set_mode(\"C1\")\n        ret = await self._device._readline()\n        ret = ret.replace(\"\\x00\", \"\")\n        df = ret.split()\n        if \"C1\" not in df[:2]:\n            raise ValueError(\"Gas Card Not in Coefficient Mode\")\n        for index in range(len(df)):\n            try:\n                df[index] = float(df[index])\n            except ValueError:\n                pass\n        return dict(zip(C1_labels, df))\n\n    async def _get_environmental(self) -&gt; dict[str, str | float]:\n        \"\"\"Gets environmental parameters.\n\n        Note:\n            **WARNING Changing any environmental parameter will lead to incorrect gas sensor operation**\n\n        Returns:\n            dict: Environmental Mode (E1) dataframe\n        \"\"\"\n        if self._current_mode != \"E1\":\n            await self._set_mode(\"E1\")\n        ret = await self._device._readline()\n        ret = ret.replace(\"\\x00\", \"\")\n        df = ret.split()\n        if \"E\" not in df[0]:\n            raise ValueError(\"Gas Card Not in Environmental Mode\")\n        for index in range(len(df)):\n            try:\n                df[index] = float(df[index])\n            except ValueError:\n                pass\n        return dict(zip(E1_labels, df))\n\n    async def _get_output(self) -&gt; dict[str, str | float]:\n        \"\"\"Display and Change output variables.\n\n        Returns:\n            dict[str, str | float]: Output Channel Mode (O1) dataframe\n        \"\"\"\n        if self._current_mode != \"O1\":\n            await self._set_mode(\"O1\")\n        ret = await self._device._readline()\n        ret = ret.replace(\"\\x00\", \"\")\n        df = ret.split()\n        if \"O1\" not in df[0:2]:\n            raise ValueError(\"Gas Card Not in Output Mode\")\n        for index in range(len(df)):\n            try:\n                df[index] = float(df[index])\n            except ValueError:\n                pass\n        return dict(zip(O1_labels, df))\n\n    async def _get_settings(self) -&gt; dict[str, str | float]:\n        \"\"\"Display and Change Settings.\n\n        Returns:\n            dict[str, str | float]: Settings mode (X) dataframe\n        \"\"\"\n        if self._current_mode != \"X\":\n            await self._set_mode(\"X\")\n        ret = await self._device._readline()\n        ret = ret.replace(\"\\x00\", \"\")\n        df = ret.split()\n        if \"X\" not in df[0]:\n            raise ValueError(\"Gas Card Not in Settings Mode\")\n        for index in range(len(df)):\n            try:\n                df[index] = float(df[index])\n            except ValueError:\n                pass\n        return dict(zip(X_labels, df))\n\n    async def _get_userinterface(self) -&gt; dict[str, str | float]:\n        \"\"\"View user Interface.\n\n        Returns:\n            dict[str, str | float]: User Interface mode (U) dataframe\n        \"\"\"\n        acc_gas = [\"CO\", \"CO2\", \"CH4\"]\n        if self._current_mode != \"U\":\n            await self._set_mode(\"U\")\n        ret = await self._device._readline()\n        ret = ret.replace(\"\\x00\", \"\")\n        df = ret.split()\n        if \"U\" not in df[0]:\n            raise ValueError(\"Gas Card Not in User Interface Mode\")\n        for index in range(len(df)):\n            try:\n                df[index] = float(df[index])\n            except ValueError:\n                pass\n        if df[2] not in acc_gas:\n            raise ValueError(\"Gas Not Accepted\")\n        return dict(zip(U_labels, df))\n\n    async def get(self, vals: list[str] | None = None) -&gt; dict[str, str | float]:\n        \"\"\"General function to receive from device.\n\n        Max acquisition rate seems to be 4 Hz\n\n        Example:\n            df = run(dev.get, [\"Gas Type\", \"Gas Range\", \"Conc 1\"])\n            df = run(dev.get, \"Gas Type\")\n\n        Args:\n            vals (list[str]): List of names (given in values dictionary) to receive from device.\n\n        Returns:\n            dict[str, str | float]: Dictionary of names requested with their values\n        \"\"\"\n        if not vals:\n            return await self._get_val()\n        modes = []\n        output = {}\n        for val in vals:\n            for key, value in values.items():\n                for idx, names in enumerate(value[0]):\n                    if val == names:\n                        modes.append((key, names))\n        unique_modes = {i[0] for i in modes}\n        MODES_FUNC = {\n            \"N\": self._get_val,\n            \"N1\": self._get_raw,\n            \"C1\": self._get_coeff,\n            \"E1\": self._get_environmental,\n            \"O1\": self._get_output,\n            \"X\": self._get_settings,\n            \"U\": self._get_userinterface,\n        }\n        for mode in unique_modes:\n            ret = await MODES_FUNC[mode]()\n            names = [i[1] for i in modes if i[0] == mode]\n            output.update({names: ret[names] for names in names})\n        return output\n\n    async def set(self, params: dict[str, str | float]) -&gt; None:\n        \"\"\"General function to send to device.\n\n        Example:\n            df = run(dev.set, {\"Time Constant\": 0, \"Pressure Sensor Offset Cor\": 904})\n\n        Args:\n            params (dict[str, str | float]): Variable:Value pairs for each desired set\n        \"\"\"\n        modes = []\n        for key, value in params.items():\n            for key2, value2 in values.items():\n                for idx, names in enumerate(value2[0]):\n                    if key == names:\n                        modes.append((key2, value2[1][idx], value))\n        unique_modes = {i[0] for i in modes}\n        for mode in unique_modes:\n            if self._current_mode != mode:\n                await self._set_mode(mode)\n            for val in [i for i in modes if i[0] == mode]:\n                await self._device._write(f\"{val[1]}{val[2]}\")\n        return\n\n    async def zero(self) -&gt; None:\n        \"\"\"Sets the zero reference of the device.\n\n        Example:\n            df = run(dev.zero)\n\n        Note:\n            **Device MUST be flowing zero gas BEFORE calling this function.**\n        \"\"\"\n        await self.set({\"Zero_Gas_Corr_Factor\": \"\"})\n        return\n\n    async def span(self, val: float) -&gt; None:\n        \"\"\"Sets the span reference of the device.\n\n        Example:\n            df = run(dev.span, 0.2126)\n\n        Note:\n            **Device MUST be flowing span gas BEFORE calling this function.**\n\n        Args:\n            val (dict[str, float]): Gas concentration as a fraction of full scale (0.5 to 1.2)\n        \"\"\"\n        await self.set({\"Span_Gas_Corr_Factor\": val})\n        return\n\n    async def time_const(self, val: int) -&gt; None:\n        \"\"\"Sets the time constant of the RC filter of the device.\n\n        Example:\n            df = run(dev.time_const, 0)\n\n        Args:\n            val (int): Time constant in seconds (0 to 120)\n        \"\"\"\n        await self.set({\"Time_Constant\": val})\n        return\n</code></pre>"},{"location":"device-reference/#pygascard.device.Gascard.__init__","title":"<code>__init__(device, dev_info, **kwargs)</code>","text":"<p>Initialize the Gascard object.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>SerialDevice</code> <p>The serial device object.</p> required <code>dev_info</code> <code>dict</code> <p>The device information dictionary.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>pygascard/device.py</code> <pre><code>def __init__(\n    self, device: SerialDevice, dev_info: dict[str, str], **kwargs: Any\n) -&gt; None:\n    \"\"\"Initialize the Gascard object.\n\n    Args:\n        device (SerialDevice): The serial device object.\n        dev_info (dict): The device information dictionary.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    self._device = device\n    self._dev_info = dev_info\n    self._current_mode = \"U\"\n    self._MODES = (\n        \"N\",\n        \"N1\",\n        \"C1\",\n        \"E1\",\n        \"O1\",\n        \"D\",\n        \"X\",\n        \"U\",\n    )\n</code></pre>"},{"location":"device-reference/#pygascard.device.Gascard.get","title":"<code>get(vals=None)</code>  <code>async</code>","text":"<p>General function to receive from device.</p> <p>Max acquisition rate seems to be 4 Hz</p> Example <p>df = run(dev.get, [\"Gas Type\", \"Gas Range\", \"Conc 1\"]) df = run(dev.get, \"Gas Type\")</p> <p>Parameters:</p> Name Type Description Default <code>vals</code> <code>list[str]</code> <p>List of names (given in values dictionary) to receive from device.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Dictionary of names requested with their values</p> Source code in <code>pygascard/device.py</code> <pre><code>async def get(self, vals: list[str] | None = None) -&gt; dict[str, str | float]:\n    \"\"\"General function to receive from device.\n\n    Max acquisition rate seems to be 4 Hz\n\n    Example:\n        df = run(dev.get, [\"Gas Type\", \"Gas Range\", \"Conc 1\"])\n        df = run(dev.get, \"Gas Type\")\n\n    Args:\n        vals (list[str]): List of names (given in values dictionary) to receive from device.\n\n    Returns:\n        dict[str, str | float]: Dictionary of names requested with their values\n    \"\"\"\n    if not vals:\n        return await self._get_val()\n    modes = []\n    output = {}\n    for val in vals:\n        for key, value in values.items():\n            for idx, names in enumerate(value[0]):\n                if val == names:\n                    modes.append((key, names))\n    unique_modes = {i[0] for i in modes}\n    MODES_FUNC = {\n        \"N\": self._get_val,\n        \"N1\": self._get_raw,\n        \"C1\": self._get_coeff,\n        \"E1\": self._get_environmental,\n        \"O1\": self._get_output,\n        \"X\": self._get_settings,\n        \"U\": self._get_userinterface,\n    }\n    for mode in unique_modes:\n        ret = await MODES_FUNC[mode]()\n        names = [i[1] for i in modes if i[0] == mode]\n        output.update({names: ret[names] for names in names})\n    return output\n</code></pre>"},{"location":"device-reference/#pygascard.device.Gascard.new_device","title":"<code>new_device(port, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Creates a new device. Chooses appropriate device based on characteristics.</p> Example <p>dev = run(Gascard.new_device, \"/dev/ttyUSB4\")</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The port of the device.</p> required <code>**kwargs</code> <code>Any</code> <p>Any</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Device</code> <code>Gascard</code> <p>The new device.</p> Source code in <code>pygascard/device.py</code> <pre><code>@classmethod\nasync def new_device(cls, port: str, **kwargs: Any) -&gt; \"Gascard\":\n    \"\"\"Creates a new device. Chooses appropriate device based on characteristics.\n\n    Example:\n        dev = run(Gascard.new_device, \"/dev/ttyUSB4\")\n\n    Args:\n        port (str): The port of the device.\n        **kwargs: Any\n\n    Returns:\n        Device: The new device.\n    \"\"\"\n    if port.startswith(\"/dev/\"):\n        device = SerialDevice(port, **kwargs)\n    await device._write(\"U\")\n    dev_info_raw = await device._readline()\n    if not dev_info_raw:\n        raise ValueError(\"No device found on port\")\n    dev_info_raw = dev_info_raw.replace(\"\\x00\", \"\")\n    dev_info = dict(zip(U_labels, dev_info_raw.split()))\n    if \"U\" not in dev_info_raw.split()[0]:\n        # print(\"Error: Gas Card Not in User Interface Mode\")\n        raise ValueError(\"Gas Card Not in User Interface Mode\")\n    return cls(device, dev_info, **kwargs)\n</code></pre>"},{"location":"device-reference/#pygascard.device.Gascard.set","title":"<code>set(params)</code>  <code>async</code>","text":"<p>General function to send to device.</p> Example <p>df = run(dev.set, {\"Time Constant\": 0, \"Pressure Sensor Offset Cor\": 904})</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict[str, str | float]</code> <p>Variable:Value pairs for each desired set</p> required Source code in <code>pygascard/device.py</code> <pre><code>async def set(self, params: dict[str, str | float]) -&gt; None:\n    \"\"\"General function to send to device.\n\n    Example:\n        df = run(dev.set, {\"Time Constant\": 0, \"Pressure Sensor Offset Cor\": 904})\n\n    Args:\n        params (dict[str, str | float]): Variable:Value pairs for each desired set\n    \"\"\"\n    modes = []\n    for key, value in params.items():\n        for key2, value2 in values.items():\n            for idx, names in enumerate(value2[0]):\n                if key == names:\n                    modes.append((key2, value2[1][idx], value))\n    unique_modes = {i[0] for i in modes}\n    for mode in unique_modes:\n        if self._current_mode != mode:\n            await self._set_mode(mode)\n        for val in [i for i in modes if i[0] == mode]:\n            await self._device._write(f\"{val[1]}{val[2]}\")\n    return\n</code></pre>"},{"location":"device-reference/#pygascard.device.Gascard.span","title":"<code>span(val)</code>  <code>async</code>","text":"<p>Sets the span reference of the device.</p> Example <p>df = run(dev.span, 0.2126)</p> Note <p>Device MUST be flowing span gas BEFORE calling this function.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>dict[str, float]</code> <p>Gas concentration as a fraction of full scale (0.5 to 1.2)</p> required Source code in <code>pygascard/device.py</code> <pre><code>async def span(self, val: float) -&gt; None:\n    \"\"\"Sets the span reference of the device.\n\n    Example:\n        df = run(dev.span, 0.2126)\n\n    Note:\n        **Device MUST be flowing span gas BEFORE calling this function.**\n\n    Args:\n        val (dict[str, float]): Gas concentration as a fraction of full scale (0.5 to 1.2)\n    \"\"\"\n    await self.set({\"Span_Gas_Corr_Factor\": val})\n    return\n</code></pre>"},{"location":"device-reference/#pygascard.device.Gascard.time_const","title":"<code>time_const(val)</code>  <code>async</code>","text":"<p>Sets the time constant of the RC filter of the device.</p> Example <p>df = run(dev.time_const, 0)</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>int</code> <p>Time constant in seconds (0 to 120)</p> required Source code in <code>pygascard/device.py</code> <pre><code>async def time_const(self, val: int) -&gt; None:\n    \"\"\"Sets the time constant of the RC filter of the device.\n\n    Example:\n        df = run(dev.time_const, 0)\n\n    Args:\n        val (int): Time constant in seconds (0 to 120)\n    \"\"\"\n    await self.set({\"Time_Constant\": val})\n    return\n</code></pre>"},{"location":"device-reference/#pygascard.device.Gascard.zero","title":"<code>zero()</code>  <code>async</code>","text":"<p>Sets the zero reference of the device.</p> Example <p>df = run(dev.zero)</p> Note <p>Device MUST be flowing zero gas BEFORE calling this function.</p> Source code in <code>pygascard/device.py</code> <pre><code>async def zero(self) -&gt; None:\n    \"\"\"Sets the zero reference of the device.\n\n    Example:\n        df = run(dev.zero)\n\n    Note:\n        **Device MUST be flowing zero gas BEFORE calling this function.**\n    \"\"\"\n    await self.set({\"Zero_Gas_Corr_Factor\": \"\"})\n    return\n</code></pre>"}]}